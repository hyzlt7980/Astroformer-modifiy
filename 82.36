import math
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, DistributedSampler
import os
import torch.distributed as dist
import random
import numpy as np
import time
from torch.nn.parallel import DistributedDataParallel as DDP
from torch.optim.lr_scheduler import LambdaLR

# ÂÖºÂÆπ PyTorch Êñ∞ÊóßÁâàÊú¨ÁöÑ AMP
try:
    from torch.amp import autocast, GradScaler
except ImportError:
    from torch.cuda.amp import autocast, GradScaler

try:
    from timm.layers import ClassifierHead, DropPath, LayerNorm, Mlp, Attention, create_conv2d, to_2tuple
    from timm.models.swin_transformer import SwinTransformerBlock as SwinBlock
    from timm.data.mixup import Mixup
    from timm.loss import SoftTargetCrossEntropy
except ImportError:
    print("Error: timm not installed. Please run 'pip install timm'")
    exit(1)

# =================================================================================
# SECTION 1: Swin-Coffee Êû∂ÊûÑ (‰øùÁïô Noise, Denoise, CBAM)
# =================================================================================

class CBAM(nn.Module):
    def __init__(self, in_planes, ratio=16):
        super().__init__()
        self.ca = nn.Sequential(
            nn.AdaptiveAvgPool1d(1),
            nn.Conv1d(in_planes, in_planes // ratio, 1, bias=False),
            nn.ReLU(),
            nn.Conv1d(in_planes // ratio, in_planes, 1, bias=False),
            nn.Sigmoid()
        )
        self.sa = nn.Sequential(
            nn.Conv2d(2, 1, 7, padding=3, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x, H, W):
        B, H, W, C = x.shape
        x_flat = x.view(B, H * W, C)
        x_p = x_flat.transpose(1, 2) 
        attn_c = self.ca(x_p).transpose(1, 2) 
        x_flat = x_flat * attn_c
        x_s = x_flat.view(B, H, W, C).permute(0, 3, 1, 2) 
        avg_out = torch.mean(x_s, dim=1, keepdim=True)
        max_out, _ = torch.max(x_s, dim=1, keepdim=True)
        attn_s = self.sa(torch.cat([avg_out, max_out], dim=1))
        x_s = x_s * attn_s
        return x_s.permute(0, 2, 3, 1)

class EnhancedDisruptBlock(nn.Module): 
    def __init__(self, dim, disturb_intensity=0.1): 
        super().__init__()
        self.dim = dim
        self.disturb_intensity = disturb_intensity
        
    def _disturb_features(self, x):
        if not self.training or random.random() > 0.5: return x
        x_perm = x.permute(0, 3, 1, 2)
        intensity = self.disturb_intensity * (0.8 + 0.6 * torch.rand(1).item())
        x_fft = torch.fft.rfft2(x_perm.float(), norm="ortho")
        mask = torch.ones_like(x_fft)
        h, w = x_fft.shape[2], x_fft.shape[3]
        h_l, w_l = int(h * intensity), int(w * intensity)
        if h_l > 0 and w_l > 0:
            h_s, w_s = random.randint(0, h-h_l), random.randint(0, w-w_l)
            mask[:, :, h_s:h_s+h_l, w_s:w_s+w_l] = 0
        x_disturbed = torch.fft.irfft2(x_fft * mask, s=(x_perm.shape[2], x_perm.shape[3]), norm="ortho").type_as(x)
        return x_disturbed.permute(0, 2, 3, 1)
    def forward(self, x): return self._disturb_features(x)

class DenoisingDisruptionBlock(nn.Module):
    def __init__(self, dim, num_heads, noise_level=0.1): 
        super().__init__()
        self.norm1 = LayerNorm(dim)
        self.attn = Attention(dim, num_heads=num_heads)
        self.norm2 = LayerNorm(dim)
        self.mlp = Mlp(in_features=dim, hidden_features=dim*4)
        self.noise_level = noise_level
        self.denoise_loss_fn = nn.MSELoss()
        self.denoise_proj = nn.Linear(dim, dim)
        
    def forward(self, x, epoch=None):
        x_clean = x
        # Ê†∏ÂøÉÔºö30ËΩÆÂêéÂºÄÂêØÂô™Â£∞
        if self.training and (epoch is not None and epoch >= 30): 
            x_noisy = x + torch.randn_like(x) * self.noise_level
        else:
            x_noisy = x 
        x_p = x_noisy + self.attn(self.norm1(x_noisy))
        x_p = x_p + self.mlp(self.norm2(x_p))
        if self.training: 
            return x_p, self.denoise_loss_fn(self.denoise_proj(x_p), x_clean.detach())
        return x_p

class AstroformerV4(nn.Module):
    def __init__(self, img_size=64, num_classes=100, embed_dims=(96, 192, 384, 768), depths=(2, 2, 6, 2)):
        super().__init__()
        self.stem = create_conv2d(3, embed_dims[0], 3, stride=2, padding=1)
        dpr = [x.item() for x in torch.linspace(0, 0.2, sum(depths))]
        self.stages = nn.ModuleList()
        in_c = embed_dims[0]
        resolutions = [img_size // 2, img_size // 4, img_size // 8, img_size // 16]
        for i in range(4):
            stride = 1 if i == 0 else 2
            curr_res = resolutions[i]
            res_tuple = (curr_res, curr_res)
            blocks = nn.ModuleList([
                SwinBlock(dim=embed_dims[i], input_resolution=res_tuple, num_heads=4 * (2**i) if i < 3 else 24, 
                          window_size=4, shift_size=0 if j%2==0 else 2, drop_path=dpr[sum(depths[:i])+j])
                for j in range(depths[i])
            ])
            down = nn.Identity()
            if i > 0:
                down = nn.Sequential(create_conv2d(in_c, embed_dims[i], 3, stride=stride, padding=1), nn.BatchNorm2d(embed_dims[i]), nn.GELU())
            self.stages.append(nn.ModuleDict({
                'down': down, 'blocks': blocks, 'cbam': CBAM(embed_dims[i]),
                'disturb': EnhancedDisruptBlock(embed_dims[i], disturb_intensity=0.1)
            }))
            in_c = embed_dims[i]
        self.final_denoise = DenoisingDisruptionBlock(embed_dims[3], 24, noise_level=0.1)
        self.norm = LayerNorm(embed_dims[3])
        self.head = nn.Linear(embed_dims[3], num_classes)

    def forward(self, x, epoch=None):
        x = self.stem(x).permute(0, 2, 3, 1) 
        for i, s in enumerate(self.stages):
            if i > 0:
                x = s['down'](x.permute(0, 3, 1, 2)).permute(0, 2, 3, 1)
            B, H, W, C = x.shape
            for blk in s['blocks']: x = blk(x)
            x = s['cbam'](x, H, W)
            # Ê†∏ÂøÉÔºö30ËΩÆÂêéÂºÄÂêØFFTÊâ∞Âä®
            if epoch is not None and epoch >= 30: x = s['disturb'](x)
        x = self.norm(x)
        out = self.final_denoise(x.view(B, H*W, C), epoch)
        feat, d_loss = out if isinstance(out, tuple) else (out, None)
        logits = self.head(feat.mean(dim=1))
        return (logits, d_loss) if self.training and d_loss is not None else logits

# =================================================================================
# SECTION 2: ËÆ≠ÁªÉÈÄªËæë
# =================================================================================

def build_scheduler(optimizer, warmup_epochs=20, max_epochs=300):
    def lr_lambda(epoch):
        if epoch < warmup_epochs: return float(epoch + 1) / warmup_epochs
        return 0.5 * (1. + math.cos(math.pi * (epoch - warmup_epochs) / (max_epochs - warmup_epochs)))
    return LambdaLR(optimizer, lr_lambda)

def main():
    if 'RANK' in os.environ:
        dist.init_process_group(backend="nccl")
        rank, local_rank = int(os.environ['RANK']), int(os.environ['LOCAL_RANK'])
    else: rank, local_rank = 0, 0
    torch.cuda.set_device(local_rank)
    device = torch.device(f"cuda:{local_rank}")

    BS = 128
    transform_train = transforms.Compose([
        transforms.Resize((64,64)), transforms.RandomHorizontalFlip(),
        transforms.RandAugment(num_ops=2, magnitude=9), transforms.ToTensor(),
        transforms.Normalize((0.5071, 0.4867, 0.4408), (0.2675, 0.2565, 0.2761)),
        transforms.RandomErasing(p=0.25)
    ])
    transform_val = transforms.Compose([
        transforms.Resize((64,64)), transforms.ToTensor(),
        transforms.Normalize((0.5071, 0.4867, 0.4408), (0.2675, 0.2565, 0.2761))
    ])

    train_data = torchvision.datasets.CIFAR100('./data', train=True, download=True, transform=transform_train)
    val_data = torchvision.datasets.CIFAR100('./data', train=False, download=True, transform=transform_val)
    train_loader = DataLoader(train_data, batch_size=BS, sampler=DistributedSampler(train_data), num_workers=8, pin_memory=True)
    val_loader = DataLoader(val_data, batch_size=BS, sampler=DistributedSampler(val_data, shuffle=False), num_workers=8)

    mixup_fn = Mixup(mixup_alpha=0.4, cutmix_alpha=0.4, prob=1.0, switch_prob=0.5, mode='batch', label_smoothing=0.1, num_classes=100)
    model_ddp = DDP(AstroformerV4().to(device), device_ids=[local_rank], find_unused_parameters=True)
    optimizer = optim.  (model_ddp.parameters(), lr=1e-3, weight_decay=0.05)
    scheduler = build_scheduler(optimizer, warmup_epochs=20, max_epochs=300)
    scaler = GradScaler()
    criterion = SoftTargetCrossEntropy()

    best_acc = 0.0
    start_time = time.time()
    
    # Ëá™Âä®ÊÅ¢Â§çÈÄªËæë
    if os.path.exists('last_checkpoint_final.pth'):
        if rank == 0: print("==> Resuming from checkpoint...")
        ckpt = torch.load('last_checkpoint_final.pth', map_location=device)
        model_ddp.module.load_state_dict(ckpt['model_state_dict'])
        optimizer.load_state_dict(ckpt['optimizer_state_dict'])
        scheduler.load_state_dict(ckpt['scheduler_state_dict'])
        best_acc = ckpt['best_acc']
        start_epoch = ckpt['epoch'] + 1
    else:
        start_epoch = 0

    for epoch in range(start_epoch, 300):
        if dist.is_initialized(): train_loader.sampler.set_epoch(epoch)
        model_ddp.train()
        avg_loss, steps = 0, 0
        
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            inputs, targets = mixup_fn(inputs, targets)
            
            # [ÂÖ≥ÈîÆ‰øÆÂ§ç] Ê∑ªÂä† device_type='cuda'
            with autocast(device_type='cuda', dtype=torch.float16):
                out = model_ddp(inputs, epoch)
                logits, d_loss = out if isinstance(out, tuple) else (out, None)
                loss = criterion(logits, targets)
                if d_loss is not None: loss += 0.1 * d_loss
            
            # Loss NaN Ê£ÄÊü•
            if not math.isfinite(loss.item()):
                print(f"Loss is {loss.item()}, stopping training")
                exit(1)

            optimizer.zero_grad()
            scaler.scale(loss).backward()
            scaler.unscale_(optimizer)
            torch.nn.utils.clip_grad_norm_(model_ddp.parameters(), max_norm=1.0)
            scaler.step(optimizer)
            scaler.update()
            avg_loss += loss.item()
            steps += 1
        
        scheduler.step()
        if rank == 0:
            current_lr = optimizer.param_groups[0]['lr']
            model_ddp.eval()
            correct, total = 0, 0
            with torch.no_grad():
                for inputs, targets in val_loader:
                    inputs, targets = inputs.to(device), targets.to(device)
                    logits = model_ddp(inputs)
                    if isinstance(logits, tuple): logits = logits[0]
                    _, predicted = logits.max(1)
                    total += targets.size(0)
                    correct += predicted.eq(targets).sum().item()
            acc = 100. * correct / total
            if acc > best_acc:
                best_acc = acc
                torch.save(model_ddp.module.state_dict(), 'best_swin_revenge.pth')
            
            torch.save({
                'epoch': epoch, 'best_acc': best_acc, 
                'model_state_dict': model_ddp.module.state_dict(),
                'optimizer_state_dict': optimizer.state_dict(), 
                'scheduler_state_dict': scheduler.state_dict()
            }, 'last_checkpoint_final.pth')

            print(f"Ep {epoch+1:03d} | Loss: {avg_loss/steps:.4f} | LR: {current_lr:.5f} | Acc: {acc:.2f}% | Best: {best_acc:.2f}% | Time: {(time.time()-start_time)/60:.1f}m")

    if dist.is_initialized(): dist.destroy_process_group()

if __name__ == '__main__': main()


-------------------------



import math, torch, torch.nn as nn, torch.nn.functional as F, torch.optim as optim
import torchvision, torchvision.transforms as transforms
from torch.utils.data import DataLoader, DistributedSampler
import os, torch.distributed as dist, random, numpy as np, time
from torch.nn.parallel import DistributedDataParallel as DDP
from torch.optim.lr_scheduler import CosineAnnealingLR

# ÂÖºÂÆπÊÄßÁªÑ‰ª∂
try:
    from torch.amp import autocast, GradScaler
except ImportError:
    from torch.cuda.amp import autocast, GradScaler

try:
    from timm.layers import LayerNorm, Mlp, Attention, create_conv2d
    from timm.models.swin_transformer import SwinTransformerBlock as SwinBlock
    from timm.data.mixup import Mixup
    from timm.loss import SoftTargetCrossEntropy
except ImportError:
    exit(1)

# =================================================================================
# SECTION 1: Êû∂ÊûÑÂÆö‰πâ (‰øùÊåÅ Code B Êû∂ÊûÑ)
# =================================================================================

class CBAM(nn.Module):
    def __init__(self, in_planes, ratio=16):
        super().__init__()
        self.ca = nn.Sequential(
            nn.AdaptiveAvgPool1d(1),
            nn.Conv1d(in_planes, in_planes // ratio, 1, bias=False),
            nn.ReLU(),
            nn.Conv1d(in_planes // ratio, in_planes, 1, bias=False),
            nn.Sigmoid()
        )
        self.sa = nn.Sequential(
            nn.Conv2d(2, 1, 7, padding=3, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x, H, W):
        B, H, W, C = x.shape
        x_flat = x.view(B, H * W, C)
        x_p = x_flat.transpose(1, 2) 
        attn_c = self.ca(x_p).transpose(1, 2) 
        x_flat = x_flat * attn_c
        x_s = x_flat.view(B, H, W, C).permute(0, 3, 1, 2) 
        avg_out = torch.mean(x_s, dim=1, keepdim=True)
        max_out, _ = torch.max(x_s, dim=1, keepdim=True)
        attn_s = self.sa(torch.cat([avg_out, max_out], dim=1))
        x_s = x_s * attn_s
        return x_s.permute(0, 2, 3, 1)

class EnhancedDisruptBlock(nn.Module): 
    def __init__(self, dim, disturb_intensity=0.05):
        super().__init__()
        self.dim = dim
        self.disturb_intensity = disturb_intensity
        
    def _disturb_features(self, x):
        if not self.training or random.random() > 0.5: return x
        x_perm = x.permute(0, 3, 1, 2)
        intensity = self.disturb_intensity * (0.8 + 0.6 * torch.rand(1).item())
        x_fft = torch.fft.rfft2(x_perm.float(), norm="ortho")
        mask = torch.ones_like(x_fft)
        h, w = x_fft.shape[2], x_fft.shape[3]
        h_l, w_l = int(h * intensity), int(w * intensity)
        if h_l > 0 and w_l > 0:
            h_s, w_s = random.randint(0, h-h_l), random.randint(0, w-w_l)
            mask[:, :, h_s:h_s+h_l, w_s:w_s+w_l] = 0
        x_disturbed = torch.fft.irfft2(x_fft * mask, s=(x_perm.shape[2], x_perm.shape[3]), norm="ortho").type_as(x)
        return x_disturbed.permute(0, 2, 3, 1)
    def forward(self, x): return self._disturb_features(x)

class DenoisingDisruptionBlock(nn.Module):
    def __init__(self, dim, num_heads, noise_level=0.1): 
        super().__init__()
        self.norm1 = LayerNorm(dim)
        self.attn = Attention(dim, num_heads=num_heads)
        self.norm2 = LayerNorm(dim)
        self.mlp = Mlp(in_features=dim, hidden_features=dim*4)
        self.noise_level = noise_level
        self.denoise_loss_fn = nn.MSELoss()
        self.denoise_proj = nn.Linear(dim, dim)
        
    def forward(self, x, epoch=None):
        x_clean = x
        if self.training: 
            x_noisy = x + torch.randn_like(x) * self.noise_level
        else:
            x_noisy = x 
        x_p = x_noisy + self.attn(self.norm1(x_noisy))
        x_p = x_p + self.mlp(self.norm2(x_p))
        if self.training: 
            return x_p, self.denoise_loss_fn(self.denoise_proj(x_p), x_clean.detach())
        return x_p

class AstroformerV4(nn.Module):
    def __init__(self, img_size=64, num_classes=100, embed_dims=(96, 192, 384, 768), depths=(2, 2, 6, 2)):
        super().__init__()
        self.stem = create_conv2d(3, embed_dims[0], 3, stride=2, padding=1)
        dpr = [x.item() for x in torch.linspace(0, 0.2, sum(depths))]
        self.stages = nn.ModuleList()
        in_c = embed_dims[0]
        resolutions = [img_size // 2, img_size // 4, img_size // 8, img_size // 16]
        for i in range(4):
            stride = 1 if i == 0 else 2
            curr_res = resolutions[i]
            res_tuple = (curr_res, curr_res)
            blocks = nn.ModuleList([
                SwinBlock(dim=embed_dims[i], input_resolution=res_tuple, num_heads=4 * (2**i) if i < 3 else 24, 
                          window_size=4, shift_size=0 if j%2==0 else 2, drop_path=dpr[sum(depths[:i])+j])
                for j in range(depths[i])
            ])
            down = nn.Identity()
            if i > 0:
                down = nn.Sequential(create_conv2d(in_c, embed_dims[i], 3, stride=stride, padding=1), nn.BatchNorm2d(embed_dims[i]), nn.GELU())
            self.stages.append(nn.ModuleDict({
                'down': down, 'blocks': blocks, 'cbam': CBAM(embed_dims[i]),
                'disturb': EnhancedDisruptBlock(embed_dims[i])
            }))
            in_c = embed_dims[i]
        self.final_denoise = DenoisingDisruptionBlock(embed_dims[3], 24, noise_level=0.1)
        self.norm = LayerNorm(embed_dims[3])
        self.head = nn.Linear(embed_dims[3], num_classes)

    def forward(self, x, epoch=None):
        x = self.stem(x).permute(0, 2, 3, 1) 
        for i, s in enumerate(self.stages):
            if i > 0:
                x = s['down'](x.permute(0, 3, 1, 2)).permute(0, 2, 3, 1)
            B, H, W, C = x.shape
            for blk in s['blocks']: x = blk(x)
            x = s['cbam'](x, H, W)
            x = s['disturb'](x)
        x = self.norm(x)
        out = self.final_denoise(x.view(B, H*W, C), epoch)
        feat, d_loss = out if isinstance(out, tuple) else (out, None)
        logits = self.head(feat.mean(dim=1))
        return (logits, d_loss) if self.training and d_loss is not None else logits

# =================================================================================
# SECTION 2: ‰∏âÈò∂ÊèêÁ∫ØÈÄªËæë
# =================================================================================

def get_params_for_stage(epoch):
    """Ê†πÊçÆÂΩìÂâç epoch ËøîÂõû‰∏âÈò∂ÊÆµÁöÑ Mixup Âíå Âô™Â£∞Âº∫Â∫¶"""
    if epoch < 15:
        # Á¨¨‰∏ÄÈò∂ÊÆµ: ‰øùÊåÅ 0.2 mixup, 0.05 Âô™Â£∞
        return 0.2, 0.050, 0.05
    elif epoch < 65:
        # Á¨¨‰∫åÈò∂ÊÆµ: Âô™Â£∞ÂáèÂçä (0.1 mixup, 0.025 Âô™Â£∞)
        return 0.1, 0.025, 0.02
    else:
        # Á¨¨‰∏âÈò∂ÊÆµ: Âô™Â£∞ÂÜçÂáèÂçä (0.05 mixup, 0.0125 Âô™Â£∞)
        return 0.05, 0.012, 0.01

def main():
    if 'RANK' in os.environ:
        dist.init_process_group(backend="nccl")
        rank, local_rank = int(os.environ['RANK']), int(os.environ['LOCAL_RANK'])
    else: rank, local_rank = 0, 0
    torch.cuda.set_device(local_rank)
    device = torch.device(f"cuda:{local_rank}")

    BS = 128
    transform_train = transforms.Compose([
        transforms.Resize((64,64)), transforms.RandomHorizontalFlip(),
        transforms.RandAugment(num_ops=2, magnitude=9), transforms.ToTensor(),
        transforms.Normalize((0.5071, 0.4867, 0.4408), (0.2675, 0.2565, 0.2761)),
        transforms.RandomErasing(p=0.25)
    ])
    transform_val = transforms.Compose([
        transforms.Resize((64,64)), transforms.ToTensor(),
        transforms.Normalize((0.5071, 0.4867, 0.4408), (0.2675, 0.2565, 0.2761))
    ])

    train_data = torchvision.datasets.CIFAR100('./data', train=True, download=True, transform=transform_train)
    val_data = torchvision.datasets.CIFAR100('./data', train=False, download=True, transform=transform_val)
    train_loader = DataLoader(train_data, batch_size=BS, sampler=DistributedSampler(train_data), num_workers=8, pin_memory=True)
    val_loader = DataLoader(val_data, batch_size=BS, sampler=DistributedSampler(val_data, shuffle=False), num_workers=8)

    model = AstroformerV4().to(device)
    model_ddp = DDP(model, device_ids=[local_rank], find_unused_parameters=True)
    
    # ‰ºòÂåñÂô®‰∏éË∞ÉÂ∫¶Âô® (115 ËΩÆÊÄªÈïø)
    optimizer = optim.AdamW(model_ddp.parameters(), lr=1e-5, weight_decay=0.05)
    scheduler = CosineAnnealingLR(optimizer, T_max=115, eta_min=1e-6)
    scaler = GradScaler()
    criterion = SoftTargetCrossEntropy()

    best_acc = 0.0
    start_epoch = 0

    # ==========================================
    # üåü Ê†∏ÂøÉÔºö‰ªé best_polished_final.pth Resume
    # ==========================================
    resume_path = 'best_polished_final.pth'
    last_ckpt_path = 'last_checkpoint_3stage.pth'

    if os.path.exists(last_ckpt_path):
        if rank == 0: print(f"==> Resuming from last 3-stage checkpoint: {last_ckpt_path}")
        ckpt = torch.load(last_ckpt_path, map_location=device)
        model_ddp.module.load_state_dict(ckpt['model_state_dict'])
        optimizer.load_state_dict(ckpt['optimizer_state_dict'])
        scheduler.load_state_dict(ckpt['scheduler_state_dict'])
        start_epoch = ckpt['epoch'] + 1
        best_acc = ckpt['best_acc']
    elif os.path.exists(resume_path):
        if rank == 0: print(f"==> Loading from {resume_path} to start 3-stage polish...")
        state_dict = torch.load(resume_path, map_location=device)
        model_ddp.module.load_state_dict(state_dict, strict=True)
    else:
        if rank == 0: print(f"Error: {resume_path} not found!")
        exit(1)

    start_time = time.time()

    for epoch in range(start_epoch, 115):
        if dist.is_initialized(): train_loader.sampler.set_epoch(epoch)
        
        # --- Âä®ÊÄÅË∞ÉÊï¥ Mixup ÂíåÂô™Â£∞Âº∫Â∫¶ ---
        mix_val, noise_val, smooth_val = get_params_for_stage(epoch)
        
        mixup_fn = Mixup(
            mixup_alpha=mix_val, cutmix_alpha=mix_val, 
            prob=1.0, switch_prob=0.5, mode='batch', 
            label_smoothing=smooth_val, num_classes=100
        )
        
        # Âº∫Âà∂Êõ¥Êñ∞Ê®°ÂûãÂÜÖÁöÑÊâ∞Âä®Âº∫Â∫¶
        for stage in model_ddp.module.stages:
            if 'disturb' in stage:
                stage['disturb'].disturb_intensity = noise_val

        model_ddp.train()
        avg_loss, steps = 0, 0
        
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            inputs, targets = mixup_fn(inputs, targets)
            
            with autocast(device_type='cuda', dtype=torch.float16):
                out = model_ddp(inputs, epoch + 300) 
                logits, d_loss = out if isinstance(out, tuple) else (out, None)
                loss = criterion(logits, targets)
                if d_loss is not None: loss += 0.1 * d_loss
            
            optimizer.zero_grad()
            scaler.scale(loss).backward()
            scaler.unscale_(optimizer)
            torch.nn.utils.clip_grad_norm_(model_ddp.parameters(), max_norm=1.0)
            scaler.step(optimizer)
            scaler.update()
            avg_loss += loss.item()
            steps += 1
        
        scheduler.step()
        
        if rank == 0:
            current_lr = optimizer.param_groups[0]['lr']
            model_ddp.eval()
            correct, total = 0, 0
            with torch.no_grad():
                for inputs, targets in val_loader:
                    inputs, targets = inputs.to(device), targets.to(device)
                    logits = model_ddp(inputs)
                    if isinstance(logits, tuple): logits = logits[0]
                    _, predicted = logits.max(1)
                    total += targets.size(0)
                    correct += predicted.eq(targets).sum().item()
            
            acc = 100. * correct / total
            if acc > best_acc:
                best_acc = acc
                torch.save(model_ddp.module.state_dict(), 'best_polished_ultimate.pth')
            
            torch.save({
                'epoch': epoch, 'best_acc': best_acc,
                'model_state_dict': model_ddp.module.state_dict(),
                'optimizer_state_dict': optimizer.state_dict(),
                'scheduler_state_dict': scheduler.state_dict(),
            }, last_ckpt_path)
            
            stage_info = "S1" if epoch < 15 else ("S2" if epoch < 65 else "S3")
            print(f"[{stage_info}] Ep {epoch+1:03d} | Mix:{mix_val:.2f} Noise:{noise_val:.3f} | Loss:{avg_loss/steps:.4f} | Acc:{acc:.2f}% | Best:{best_acc:.2f}% | Time:{(time.time()-start_time)/60:.1f}m")

    if dist.is_initialized(): dist.destroy_process_group()

if __name__ == '__main__': main()

-------------------------------------------


[S1] Ep 001 | Mix:0.20 Noise:0.050 | Loss:1.0285 | Acc:81.68% | Best:81.68% | Time:0.3m
[S1] Ep 002 | Mix:0.20 Noise:0.050 | Loss:1.2464 | Acc:81.12% | Best:81.68% | Time:0.6m
[S1] Ep 003 | Mix:0.20 Noise:0.050 | Loss:0.9995 | Acc:81.52% | Best:81.68% | Time:0.9m
[S1] Ep 004 | Mix:0.20 Noise:0.050 | Loss:1.1825 | Acc:81.76% | Best:81.76% | Time:1.2m
[S1] Ep 005 | Mix:0.20 Noise:0.050 | Loss:1.1335 | Acc:81.68% | Best:81.76% | Time:1.5m
[S1] Ep 006 | Mix:0.20 Noise:0.050 | Loss:1.1700 | Acc:81.84% | Best:81.84% | Time:1.8m
[S1] Ep 007 | Mix:0.20 Noise:0.050 | Loss:1.2299 | Acc:81.20% | Best:81.84% | Time:2.1m
[S1] Ep 008 | Mix:0.20 Noise:0.050 | Loss:1.1607 | Acc:81.48% | Best:81.84% | Time:2.4m
[S1] Ep 009 | Mix:0.20 Noise:0.050 | Loss:1.2761 | Acc:81.52% | Best:81.84% | Time:2.7m
[S1] Ep 010 | Mix:0.20 Noise:0.050 | Loss:1.1485 | Acc:81.64% | Best:81.84% | Time:3.0m
[S1] Ep 011 | Mix:0.20 Noise:0.050 | Loss:1.0932 | Acc:81.52% | Best:81.84% | Time:3.3m
[S1] Ep 012 | Mix:0.20 Noise:0.050 | Loss:1.0849 | Acc:81.84% | Best:81.84% | Time:3.6m
[S1] Ep 013 | Mix:0.20 Noise:0.050 | Loss:1.1479 | Acc:81.12% | Best:81.84% | Time:3.9m
[S1] Ep 014 | Mix:0.20 Noise:0.050 | Loss:1.1568 | Acc:81.48% | Best:81.84% | Time:4.2m
[S1] Ep 015 | Mix:0.20 Noise:0.050 | Loss:1.2552 | Acc:81.16% | Best:81.84% | Time:4.5m
[S2] Ep 016 | Mix:0.10 Noise:0.025 | Loss:0.8514 | Acc:81.60% | Best:81.84% | Time:4.8m
[S2] Ep 017 | Mix:0.10 Noise:0.025 | Loss:0.6957 | Acc:81.88% | Best:81.88% | Time:5.1m
[S2] Ep 018 | Mix:0.10 Noise:0.025 | Loss:0.6869 | Acc:81.72% | Best:81.88% | Time:5.4m
[S2] Ep 019 | Mix:0.10 Noise:0.025 | Loss:0.8902 | Acc:81.80% | Best:81.88% | Time:5.7m
[S2] Ep 020 | Mix:0.10 Noise:0.025 | Loss:0.6515 | Acc:82.08% | Best:82.08% | Time:6.0m
[S2] Ep 021 | Mix:0.10 Noise:0.025 | Loss:0.9001 | Acc:81.64% | Best:82.08% | Time:6.3m
[S2] Ep 022 | Mix:0.10 Noise:0.025 | Loss:0.7660 | Acc:81.76% | Best:82.08% | Time:6.5m
[S2] Ep 023 | Mix:0.10 Noise:0.025 | Loss:0.7801 | Acc:81.56% | Best:82.08% | Time:6.8m
[S2] Ep 024 | Mix:0.10 Noise:0.025 | Loss:0.7477 | Acc:81.28% | Best:82.08% | Time:7.1m
[S2] Ep 025 | Mix:0.10 Noise:0.025 | Loss:0.8070 | Acc:81.72% | Best:82.08% | Time:7.4m
[S2] Ep 026 | Mix:0.10 Noise:0.025 | Loss:0.7632 | Acc:81.72% | Best:82.08% | Time:7.7m
[S2] Ep 027 | Mix:0.10 Noise:0.025 | Loss:0.8407 | Acc:81.72% | Best:82.08% | Time:8.0m
[S2] Ep 028 | Mix:0.10 Noise:0.025 | Loss:0.8198 | Acc:81.80% | Best:82.08% | Time:8.3m
[S2] Ep 029 | Mix:0.10 Noise:0.025 | Loss:0.8371 | Acc:82.04% | Best:82.08% | Time:8.6m
[S2] Ep 030 | Mix:0.10 Noise:0.025 | Loss:0.7744 | Acc:82.08% | Best:82.08% | Time:8.9m
[S2] Ep 031 | Mix:0.10 Noise:0.025 | Loss:0.6703 | Acc:81.96% | Best:82.08% | Time:9.2m
[S2] Ep 032 | Mix:0.10 Noise:0.025 | Loss:0.8747 | Acc:81.72% | Best:82.08% | Time:9.5m
[S2] Ep 033 | Mix:0.10 Noise:0.025 | Loss:0.7545 | Acc:81.64% | Best:82.08% | Time:9.8m
[S2] Ep 034 | Mix:0.10 Noise:0.025 | Loss:0.8486 | Acc:81.52% | Best:82.08% | Time:10.1m
[S2] Ep 035 | Mix:0.10 Noise:0.025 | Loss:0.8236 | Acc:81.76% | Best:82.08% | Time:10.3m
[S2] Ep 036 | Mix:0.10 Noise:0.025 | Loss:0.8662 | Acc:81.92% | Best:82.08% | Time:10.6m
[S2] Ep 037 | Mix:0.10 Noise:0.025 | Loss:0.7687 | Acc:81.84% | Best:82.08% | Time:10.9m
[S2] Ep 038 | Mix:0.10 Noise:0.025 | Loss:0.8047 | Acc:81.40% | Best:82.08% | Time:11.2m
[S2] Ep 039 | Mix:0.10 Noise:0.025 | Loss:0.7214 | Acc:81.92% | Best:82.08% | Time:11.5m
[S2] Ep 040 | Mix:0.10 Noise:0.025 | Loss:0.8299 | Acc:81.44% | Best:82.08% | Time:11.8m
[S2] Ep 041 | Mix:0.10 Noise:0.025 | Loss:0.7820 | Acc:81.56% | Best:82.08% | Time:12.1m
[S2] Ep 042 | Mix:0.10 Noise:0.025 | Loss:0.8195 | Acc:81.72% | Best:82.08% | Time:12.4m
[S2] Ep 043 | Mix:0.10 Noise:0.025 | Loss:0.7354 | Acc:81.88% | Best:82.08% | Time:12.7m
[S2] Ep 044 | Mix:0.10 Noise:0.025 | Loss:0.7348 | Acc:82.00% | Best:82.08% | Time:13.0m
[S2] Ep 045 | Mix:0.10 Noise:0.025 | Loss:0.8477 | Acc:81.44% | Best:82.08% | Time:13.3m
[S2] Ep 046 | Mix:0.10 Noise:0.025 | Loss:0.8107 | Acc:81.56% | Best:82.08% | Time:13.6m
[S2] Ep 047 | Mix:0.10 Noise:0.025 | Loss:0.8746 | Acc:81.56% | Best:82.08% | Time:13.9m
[S2] Ep 048 | Mix:0.10 Noise:0.025 | Loss:0.7016 | Acc:81.64% | Best:82.08% | Time:14.2m
[S2] Ep 049 | Mix:0.10 Noise:0.025 | Loss:0.8246 | Acc:81.76% | Best:82.08% | Time:14.5m
[S2] Ep 050 | Mix:0.10 Noise:0.025 | Loss:0.7504 | Acc:81.12% | Best:82.08% | Time:14.8m
[S2] Ep 051 | Mix:0.10 Noise:0.025 | Loss:0.6781 | Acc:81.56% | Best:82.08% | Time:15.0m
[S2] Ep 052 | Mix:0.10 Noise:0.025 | Loss:0.7679 | Acc:81.64% | Best:82.08% | Time:15.3m
[S2] Ep 053 | Mix:0.10 Noise:0.025 | Loss:0.8042 | Acc:81.48% | Best:82.08% | Time:15.6m
[S2] Ep 054 | Mix:0.10 Noise:0.025 | Loss:0.7266 | Acc:81.68% | Best:82.08% | Time:15.9m
[S2] Ep 055 | Mix:0.10 Noise:0.025 | Loss:0.6696 | Acc:81.92% | Best:82.08% | Time:16.2m
[S2] Ep 056 | Mix:0.10 Noise:0.025 | Loss:0.7550 | Acc:81.56% | Best:82.08% | Time:16.5m
[S2] Ep 057 | Mix:0.10 Noise:0.025 | Loss:0.8512 | Acc:82.00% | Best:82.08% | Time:16.8m
[S2] Ep 058 | Mix:0.10 Noise:0.025 | Loss:0.7421 | Acc:81.84% | Best:82.08% | Time:17.1m
[S2] Ep 059 | Mix:0.10 Noise:0.025 | Loss:0.8228 | Acc:81.96% | Best:82.08% | Time:17.4m
[S2] Ep 060 | Mix:0.10 Noise:0.025 | Loss:0.8240 | Acc:82.04% | Best:82.08% | Time:17.7m
[S2] Ep 061 | Mix:0.10 Noise:0.025 | Loss:0.7786 | Acc:82.12% | Best:82.12% | Time:18.0m
[S2] Ep 062 | Mix:0.10 Noise:0.025 | Loss:0.6851 | Acc:81.80% | Best:82.12% | Time:18.3m
[S2] Ep 063 | Mix:0.10 Noise:0.025 | Loss:0.7062 | Acc:81.76% | Best:82.12% | Time:18.5m
[S2] Ep 064 | Mix:0.10 Noise:0.025 | Loss:0.8355 | Acc:81.52% | Best:82.12% | Time:18.8m
[S2] Ep 065 | Mix:0.10 Noise:0.025 | Loss:0.6319 | Acc:81.96% | Best:82.12% | Time:19.1m
[S3] Ep 066 | Mix:0.05 Noise:0.012 | Loss:0.5903 | Acc:81.88% | Best:82.12% | Time:19.4m
[S3] Ep 067 | Mix:0.05 Noise:0.012 | Loss:0.7645 | Acc:82.00% | Best:82.12% | Time:19.7m
[S3] Ep 068 | Mix:0.05 Noise:0.012 | Loss:0.6445 | Acc:81.92% | Best:82.12% | Time:20.0m
[S3] Ep 069 | Mix:0.05 Noise:0.012 | Loss:0.6050 | Acc:82.12% | Best:82.12% | Time:20.3m
[S3] Ep 070 | Mix:0.05 Noise:0.012 | Loss:0.6855 | Acc:81.64% | Best:82.12% | Time:20.6m
[S3] Ep 071 | Mix:0.05 Noise:0.012 | Loss:0.6430 | Acc:81.96% | Best:82.12% | Time:20.8m
[S3] Ep 072 | Mix:0.05 Noise:0.012 | Loss:0.6236 | Acc:82.12% | Best:82.12% | Time:21.1m
[S3] Ep 073 | Mix:0.05 Noise:0.012 | Loss:0.5980 | Acc:82.04% | Best:82.12% | Time:21.4m
[S3] Ep 074 | Mix:0.05 Noise:0.012 | Loss:0.5928 | Acc:81.92% | Best:82.12% | Time:21.7m
[S3] Ep 075 | Mix:0.05 Noise:0.012 | Loss:0.6979 | Acc:81.92% | Best:82.12% | Time:22.0m
[S3] Ep 076 | Mix:0.05 Noise:0.012 | Loss:0.6683 | Acc:82.28% | Best:82.28% | Time:22.3m
[S3] Ep 077 | Mix:0.05 Noise:0.012 | Loss:0.6364 | Acc:82.32% | Best:82.32% | Time:22.6m
[S3] Ep 078 | Mix:0.05 Noise:0.012 | Loss:0.5144 | Acc:81.92% | Best:82.32% | Time:22.9m
[S3] Ep 079 | Mix:0.05 Noise:0.012 | Loss:0.6524 | Acc:82.28% | Best:82.32% | Time:23.2m
[S3] Ep 080 | Mix:0.05 Noise:0.012 | Loss:0.5303 | Acc:82.28% | Best:82.32% | Time:23.5m
[S3] Ep 081 | Mix:0.05 Noise:0.012 | Loss:0.6531 | Acc:81.96% | Best:82.32% | Time:23.8m
[S3] Ep 082 | Mix:0.05 Noise:0.012 | Loss:0.5423 | Acc:82.24% | Best:82.32% | Time:24.1m
[S3] Ep 083 | Mix:0.05 Noise:0.012 | Loss:0.5514 | Acc:82.04% | Best:82.32% | Time:24.4m
[S3] Ep 084 | Mix:0.05 Noise:0.012 | Loss:0.5856 | Acc:81.96% | Best:82.32% | Time:24.7m
[S3] Ep 085 | Mix:0.05 Noise:0.012 | Loss:0.5072 | Acc:82.04% | Best:82.32% | Time:24.9m
[S3] Ep 086 | Mix:0.05 Noise:0.012 | Loss:0.5034 | Acc:82.08% | Best:82.32% | Time:25.2m
[S3] Ep 087 | Mix:0.05 Noise:0.012 | Loss:0.6172 | Acc:82.20% | Best:82.32% | Time:25.5m
[S3] Ep 088 | Mix:0.05 Noise:0.012 | Loss:0.5153 | Acc:81.80% | Best:82.32% | Time:25.8m
[S3] Ep 089 | Mix:0.05 Noise:0.012 | Loss:0.6187 | Acc:82.04% | Best:82.32% | Time:26.1m
[S3] Ep 090 | Mix:0.05 Noise:0.012 | Loss:0.6083 | Acc:81.64% | Best:82.32% | Time:26.4m
[S3] Ep 091 | Mix:0.05 Noise:0.012 | Loss:0.5278 | Acc:81.88% | Best:82.32% | Time:26.7m
[S3] Ep 092 | Mix:0.05 Noise:0.012 | Loss:0.5147 | Acc:82.28% | Best:82.32% | Time:27.0m
[S3] Ep 093 | Mix:0.05 Noise:0.012 | Loss:0.6321 | Acc:81.88% | Best:82.32% | Time:27.3m
[S3] Ep 094 | Mix:0.05 Noise:0.012 | Loss:0.6454 | Acc:82.28% | Best:82.32% | Time:27.6m
[S3] Ep 095 | Mix:0.05 Noise:0.012 | Loss:0.6414 | Acc:81.92% | Best:82.32% | Time:27.9m
[S3] Ep 096 | Mix:0.05 Noise:0.012 | Loss:0.6717 | Acc:81.84% | Best:82.32% | Time:28.2m
[S3] Ep 097 | Mix:0.05 Noise:0.012 | Loss:0.6068 | Acc:82.00% | Best:82.32% | Time:28.5m
[S3] Ep 098 | Mix:0.05 Noise:0.012 | Loss:0.5231 | Acc:82.24% | Best:82.32% | Time:28.8m
[S3] Ep 099 | Mix:0.05 Noise:0.012 | Loss:0.5429 | Acc:81.84% | Best:82.32% | Time:29.1m
[S3] Ep 100 | Mix:0.05 Noise:0.012 | Loss:0.5628 | Acc:81.80% | Best:82.32% | Time:29.4m
[S3] Ep 101 | Mix:0.05 Noise:0.012 | Loss:0.5385 | Acc:82.24% | Best:82.32% | Time:29.7m
[S3] Ep 102 | Mix:0.05 Noise:0.012 | Loss:0.5141 | Acc:81.88% | Best:82.32% | Time:29.9m
[S3] Ep 103 | Mix:0.05 Noise:0.012 | Loss:0.5805 | Acc:82.36% | Best:82.36% | Time:30.2m
[S3] Ep 104 | Mix:0.05 Noise:0.012 | Loss:0.6456 | Acc:82.00% | Best:82.36% | Time:30.5m
[S3] Ep 105 | Mix:0.05 Noise:0.012 | Loss:0.5385 | Acc:82.32% | Best:82.36% | Time:30.8m
[S3] Ep 106 | Mix:0.05 Noise:0.012 | Loss:0.5579 | Acc:81.92% | Best:82.36% | Time:31.1m
[S3] Ep 107 | Mix:0.05 Noise:0.012 | Loss:0.6396 | Acc:81.96% | Best:82.36% | Time:31.4m
[S3] Ep 108 | Mix:0.05 Noise:0.012 | Loss:0.5823 | Acc:81.72% | Best:82.36% | Time:31.7m
[S3] Ep 109 | Mix:0.05 Noise:0.012 | Loss:0.5549 | Acc:81.96% | Best:82.36% | Time:32.0m
[S3] Ep 110 | Mix:0.05 Noise:0.012 | Loss:0.6352 | Acc:81.68% | Best:82.36% | Time:32.3m
[S3] Ep 111 | Mix:0.05 Noise:0.012 | Loss:0.5700 | Acc:82.24% | Best:82.36% | Time:32.6m
[S3] Ep 112 | Mix:0.05 Noise:0.012 | Loss:0.5827 | Acc:81.48% | Best:82.36% | Time:32.8m
[S3] Ep 113 | Mix:0.05 Noise:0.012 | Loss:0.6553 | Acc:81.88% | Best:82.36% | Time:33.1m
[S3] Ep 114 | Mix:0.05 Noise:0.012 | Loss:0.6719 | Acc:81.56% | Best:82.36% | Time:33.4m
[S3] Ep 115 | Mix:0.05 Noise:0.012 | Loss:0.5715 | Acc:81.72% | Best:82.36% | Time:33.7m
